#!/usr/bin/perl

use Font::TTF::Font;
use Getopt::Std;
use IO::File;
use Pod::Usage;

use strict;
our $VERSION = 0.1;     #   

our $CHAIN_CALL;
our %opts;
our $f;

unless($CHAIN_CALL)
{
    pod2usage(-verbose => 1) unless (getopts('d:g:hl:s:', \%opts) && $#ARGV == 1) || $opts{'h'};
    pod2usage(-verbose => 2, -noperldoc => 1) if $opts{'h'};
    $f = Font::TTF::Font->open($ARGV[0]) || die "Can't open file '$ARGV[0]'";
}

if ($opts{'d'})
{
    # expand magic words.
    $opts{'d'} =~ s/\bgraphite\b/ Silf Feat Gloc Glat Sill Sile /oi; 
    $opts{'d'} =~ s/\bvolt\b/ TSIV TSID TSIP TSIS /oi;
    $opts{'d'} =~ s/\bopentype\b/ GDEF GSUB GPOS /oi;
    # Split generously (spaces, comma, colon, semicolon)
    foreach my $tag (grep {length($_) == 4} split(/[\s,:;]+/, $opts{'d'}))
    {
    	delete $f->{$tag} if exists $f->{$tag};
    }
}

my $subsetter = Font::TTF::Scripts::SubSetter->new();
my $cmap = $f->{'cmap'}->read->find_ms;
my $post = $f->{'post'}->read;
if ($opts{'g'})
{
    my ($fh) = IO::File->new($opts{'g'}, "r") || die "Can't open $opts{'g'} for reading";
    while (<$fh>)
    {
        foreach my $g (split)
        {
            my ($n, $u) = split(/=/, $g);
            if ($n =~ m/^U\+/oi)
            { $n = $cmap->{'val'}{hex($')}; }
            elsif ($n !~ m/^\d/o)
            { $n = $post->{'STRINGS'}{$n}; }
            if ($n)
            {
                $subsetter->add_glyph($n);
                if ($u)
                { $subsetter->remap(hex($u), $n); }
            }
        }
    }
    $fh->close();
}

if ($opts{'l'})
{
    $subsetter->langlist(split(' ', $opts{'l'}));
}

if ($opts{'s'})
{
    $subsetter->scriptlist(split(' ', $opts{'s'}));
}

$f->tables_do(sub {$_[0]->subset($subsetter);});
$f->out($ARGV[1]);

package Font::TTF::Scripts::SubSetter;

sub new
{
    my ($class) = @_;
    my ($self) = {};
    $self->{'glyphs'} = '';
    $self->{'remaps'} = {};
    bless $self, $class || ref $class;
    foreach (0..2) { $self->add_glyph($_); }
    return $self;
}

sub add_glyph
{
    my ($self, $n) = @_;
    vec($self->{'glyphs'}, $n, 1) = 1;
}

sub keep_glyph
{
    my ($self, $n) = @_;
    return vec($self->{'glyphs'}, $n, 1);
}

sub remap
{
    my ($self, $u, $n) = @_;
    $self->{'remaps'}{$u} = $n;
}

sub langlist
{
    my ($self, @dat) = @_;
    $self->{'langs'} = { map {$_=>1} @dat };
}

sub scriptlist
{
    my ($self, @dat) = @_;
    $self->{'scripts'} = { map {$_=>1} @dat };
}

sub map_glyph
{
    my ($self, $g) = @_;
    # no glyph remapping yet
    return $g;
}

package Font::TTF::Table;

sub subset
{
    my ($self, $subsetter) = @_;
    $self->read;
    $self->dirty;
}

package Font::TTF::Loca;

sub subset
{
    my ($self, $subsetter) = @_;
    my ($numg) = $self->{' PARENT'}{'maxp'}{'numGlyphs'};
    my ($i);

    $self->SUPER::subset($subsetter);
    # todo: add glyph remapping
    for ($i = 0; $i < $numg; $i++)
    {
        if (!$subsetter->keep_glyph($i))
        { undef $self->{'glyphs'}[$i]; }
    }
}

package Font::TTF::Ttopen;

sub subset
{
    my ($self, $subsetter) = @_;
    my ($l, $s);
    $self->SUPER::subset($subsetter);

    my ($count, @lmap);
    foreach $l (0 .. @{$self->{'LOOKUP'}})
    {
        my $res = [];
        foreach $s (@{$self->{'LOOKUP'}[$l]{'SUB'}})
        {
            if ($s->{'COVERAGE'} && !$self->subset_cover($subsetter, $s->{'COVERAGE'}, $s->{'RULES'}))
            { $s->{'isEmpty'} = 1; }
            $self->subset_subtable($subsetter, $s, $self->{'LOOKUP'}[$l]);
            if (!@{$s->{'RULES'}})
            { next; }
            # remove unused coverage indices
            if ($s->{'COVERAGE'})
            {
                my $c = $s->{'COVERAGE'}{'val'};
                my $i = 0;
                foreach my $k (sort {$c->{$a} <=> $c->{$b}} keys %{$c})
                { $c->{k} = $i++; }
            }
            push (@{$res}, $s);
        }
        if (!@{$res})
        {
            push (@lmap, -1);
            delete $self->{'LOOKUP'}[$l];
        }
        else
        {
            $self->{'LOOKUP'}[$l]{'SUB'} = $res;
            push (@lmap, $count++);
        }
    }

    foreach my $t (@{$self->{'FEATURES'}{'FEAT_TAGS'}})
    {
        my $f = $self->{'FEATURES'}{$t};
        foreach $l (0 .. @{$f->{'LOOKUPS'}})
        {
            my ($v) = $lmap[$f->{'LOOKUPS'}[$l]];
            if ($v < 0)
            { delete $f->{'LOOKUPS'}[$l]; }
            else
            { $f->{'LOOKUPS'}[$l] = $v; }
        }
        if (!@{$f->{'LOOKUPS'}})
        { delete $self->{'FEATURES'}{$t}; }
    }

    my ($isEmpty) = 1;
    foreach $s (keys %{$self->{'SCRIPTS'}})
    {
        foreach $l (-1 .. @{$self->{'SCRIPTS'}{$s}{'LANG_TAGS'}})
        {
            my $lang;
            if ($l < 0)
            { $lang = $self->{'SCRIPTS'}{$s}{'DEFAULT'}; }
            else
            { $lang = $self->{'SCRIPTS'}{$s}{$self->{'SCRIPTS'}{$s}{'LANG_TAGS'}[$l]}; }

            if (defined $lang->{'FEATURES'})
            {
                foreach my $i (0 .. @{$lang->{'FEATURES'}})
                {
                    if (!defined $self->{'FEATURES'}{$lang->{'FEATURES'}[$i]})
                    { delete $lang->{'FEATURES'}[$i]; }
                }
            }
            if (defined $lang->{'DEFAULT'} && $lang->{'DEFAULT'} >= 0)
            {
                my ($found) = 0;
                foreach my $f (@{$self->{'FEATURES'}{'FEAT_TAGS'}})
                {
                    if ($self->{'FEATURES'}{$f}{'INDEX'} == $lang->{'DEFAULT'})
                    {
                        $found = 1;
                        last;
                    }
                }
                if (!$found)
                { $lang->{'DEFAULT'} = -1; }
            }
            if (($l >= 0 && defined $subsetter->{'langs'}
                && !defined $subsetter->{'langs'}{$self->{'SCRIPTS'}{$s}{'LANG_TAGS'}[$l]})
                    || ((!defined $lang->{'FEATURES'} || !@{$lang->{'FEATURES'}})
                        && (!defined $lang->{'DEFAULT'} || $lang->{'DEFAULT'} < 0)))
            {
                if ($l < 0)
                { delete $self->{'SCRIPTS'}{$s}{'DEFAULT'}; }
                else
                {
                    delete $self->{'SCRIPTS'}{$s}{$self->{'SCRIPTS'}{$s}{'LANG_TAGS'}[$l]};
                    delete $self->{'SCRIPTS'}{$s}{'LANG_TAGS'}[$l];
                }
            }
        }
        if ((defined $subsetter->{'scripts'} && !defined $subsetter->{'scripts'}{$s})
                || (!@{$self->{'SCRIPTS'}{$s}{'LANG_TAGS'}} && !defined $self->{'SCRIPTS'}{$s}{'DEFAULT'}))
        {
            delete $self->{'SCRIPTS'}{$s};
            next;
        }
        else
        { $isEmpty = 0; }
    }
    if ($isEmpty)
    {
        my ($k, $v);
        while (($k, $v) = each %{$self->{' PARENT'}})
        {
            if ($v eq $self)
            {
                delete $self->{' PARENT'}{$k};
                last;
            }
        }
    }
}

sub subset_class
{
    my ($self, $subsetter, $class) = @_;
    my ($res) = [];

    foreach (sort {$b <=> $a} keys %{$class})
    {
        if (!$subsetter->keep_glyph($_))
        { delete $class->{$_}; }
        else
        {
            my $g = $subsetter->map_glyph($_);
            $class->{$g} = delete $class->{$_};
            $res->[$class->{$g}] = 1;
        }
    }
    return $res;
}

sub subset_cover
{
    my ($self, $subsetter, $coverage, $rules) = @_;
    return $coverage if (defined $coverage->{'isremapped'});
    my $isEmpty = 1;
    my $cover = $coverage->{'val'};
    foreach (keys %{$cover})
    {
        if (!$subsetter->keep_glyph($_))
        {
            delete $rules->[$cover->{$_}] if $rules;
            delete $cover->{$_};
        }
        else
        {
            $cover->{$subsetter->map_glyph($_)} = delete $cover->{$_};
            $isEmpty = 0;
        }
    }
    if ($isEmpty)
    { return undef; }
    else
    {
        $coverage->{'isremapped'} = 1;
        return $coverage;
    }
}

sub subset_context
{
    my ($self, $subsetter, $sub, $type) = @_;
    my ($fmt) = $sub->{'FORMAT'};
    my (@gids) = sort { $a <=> $b} keys %{$sub->{'COVERAGE'}{'val'}};
    my ($classvals, $prevals, $postvals, $i, $j);

    $classvals = subset_class($subsetter, $sub->{'CLASS'}) if (defined $sub->{'CLASS'});
    $prevals = subset_class($subsetter, $sub->{'PRE_CLASS'}) if (defined $sub->{'PRE_CLASS'});
    $postvals = subset_class($subsetter, $sub->{'POST_CLASS'}) if (defined $sub->{'POST_CLASS'});

    foreach $i (0 .. @{$sub->{'RULES'}})
    {
        my ($isEmpty) = 1;
        if ($sub->{'RULES'}[$i])
        {
            foreach $j (0 .. @{$sub->{'RULES'}[$i]})
            {
                my ($r) = $sub->{'RULES'}[$i][$j];
                my ($test) = 1;
                $test = $subsetter->keep_glyph($sub->{'RULES'}[$i][$j]{'ACTION'}[0]) if ($type == 4);
                if ($test && $type == 6 && defined $r->{'PRE'})
                {
                    foreach (@{$r->{'PRE'}})
                    {
                        if ($fmt == 1 && $subsetter->keep_glyph($_))
                        { $_ = $subsetter->map_glyph($_); }
                        elsif ($fmt == 2 && $prevals->[$_])
                        { }
                        elsif ($fmt == 3 && $self->subset_cover($subsetter, $_, undef))
                        { }
                        else
                        {
                            $test = 0;
                            last;
                        }
                    }
                }
                if ($test && $type == 6 && defined $r->{'POST'})
                {
                    foreach (@{$r->{'POST'}})
                    {
                        if ($fmt == 1 && $subsetter->keep_glyph($_))
                        { $_ = $subsetter->map_glyph($_); }
                        elsif ($fmt == 2 && $postvals->[$_])
                        { }
                        elsif ($fmt == 3 && $self->subset_cover($subsetter, $_, undef))
                        { }
                        else
                        {
                            $test = 0;
                            last;
                        }
                    }
                }
                if ($test)
                {
                    foreach (@{$r->{'POST'}})
                    {
                        if (($fmt == 1 || $type == 4) && $subsetter->keep_glyph($_))
                        { $_ = $subsetter->map_glyph($_); }
                        elsif ($fmt == 2 && $type != 4 && $classvals->[$_])
                        { }
                        elsif ($fmt == 3 && $type != 4 && $self->subset_cover($subsetter, $_, undef))
                        { }
                        else
                        {
                            $test = 0;
                            last;
                        }
                    }
                }
                if (!$test)
                { delete $sub->{'RULES'}[$i][$j]; }
                else
                { $isEmpty = 0; }
            }
        }
        if ($isEmpty)
        {
            delete $sub->{'RULES'}[$i];
            delete $sub->{'COVERAGE'}{'val'}{$gids[$i]};  # already remapped
        }
    }
}

package Font::TTF::GSUB;

sub subset_subtable
{
    my ($self, $subsetter, $sub, $lookup) = @_;
    my ($type) = $lookup->{'TYPE'};
    my ($fmt) = $sub->{'FORMAT'};
    my (@gids) = sort { $a <=> $b} keys %{$sub->{'COVERAGE'}{'val'}};
    my ($r, $i, $j);

    if (($type == 1 && $fmt > 1) || $type == 2)
    {
        foreach $i (0 .. @{$sub->{'RULES'}})
        {
            next unless (defined $sub->{'RULES'}[$i]);
            foreach $j (@{$sub->{'RULES'}[$i][0]{'ACTION'}})
            {
                if (!$subsetter->keep_glyph($j))
                {
                    delete $sub->{'RULES'}[$i];
                    delete $sub->{'COVERAGE'}{'val'}{$gids[$i]}; # already remapped
                    last;
                }
                else
                { $j = $subsetter->map_glyph($j); }
            }
        }
    }
    elsif ($type == 3)
    {
        foreach $i (0 .. @{$sub->{'RULES'}})
        {
            next unless (defined $sub->{'RULES'}[$i]);
            my $res = [];
            foreach $j (@{$sub->{'RULES'}[$i][0]{'ACTION'}})
            {
                if ($subsetter->keep_glyph($j))
                { push (@{$res}, $subsetter->map_glyph($j)); }
            }
            if (@{$res})
            { $sub->{'RULES'}[$i][0]{'ACTION'} = $res; }
            else
            {
                delete $sub->{'RULES'}[$i];
                delete $sub->{'COVERAGE'}{'val'}{$gids[$i]};  # already remapped
            }
        }
    }
    else
    { $self->subset_context($subsetter, $sub, $type); }
}

package Font::TTF::GPOS;

sub subset_subtable
{ }

__END__

=head1 TITLE

ttfsubset - subset a font

=head1 SYNOPSIS

ttfsubset [options] infont outfont

Opens infont (a .ttf file), subsets it according to the supplied options, then writes the resulting file to outfont.

=head1 OPTIONS

  -h            Get full help
  -d tag[,...]	List of font tables to remove.
  -g listfile	File containing list of glyphs to retain 
  -s tag[,...]	List of OpenType script tags to retain
  -l tag[,...]  List of OpenType language tags to retain

=head1 DESCRIPTION

ttfsubset removes parts of a font in order to produce a working, smaller, font. Multiple subsetting 
strategies are provided and controlled by options.

The C<-d> option is used to delete whole font tables, e.g., all Graphite tables. A 
list of four-letter table tags identifies the tables to be removed. As in L<ttftable>, 
the following (case insensitive) pseudo tags can also be used:

  graphite  all SIL Graphite tables (Silf Feat Gloc Glat Sill Sile)
  volt      all Microsoft VOLT tables (TSIV TSID TSIP TSIS)
  opentype  all OpenTYpe tables (GDEF GSUB GPOS)

The C<-g> option specifies a file that lists glyphs to be retained in the 
subset font -- ttfsubset will remove all other glyphs and then do what it can to simplify
remaining features.  Glyphs are identified in the file using space-separated indentifiers which
can be decimal numeric glyph IDs, postscript glyph names, or hexidecimal Unicode scalar values in the format
of U+xxxx. Numeric or postscript glyph identifiers can be followed immediately by equals sign and 4 to 6 hex digits to
indicate the glyph should be encoded.

The C<-s> and C<-l> options identify OpenType script and language (respectively) tags
to retain in the font. The Default language is always retained, so specify C<-l ''> to remove all but the default language. 

=head1 BUGS

ttfsubset is an evolving tool and the invitation is given to contribute improvements that will result
in smaller output fonts.

=cut
