#!/usr/bin/perl

use Font::TTF::Font;
use Font::TTF::Scripts::Name;
use Getopt::Std;
use IO::File;
use Pod::Usage;

use strict;
our $VERSION = 0.1;     #   

our $CHAIN_CALL;
our %opts;
our $f;

unless($CHAIN_CALL)
{
    pod2usage(-verbose => 1) unless (getopts('d:g:hl:n:s:', \%opts) && $#ARGV == 1) || $opts{'h'};
    pod2usage(-verbose => 2, -noperldoc => 1) if $opts{'h'};
    $f = Font::TTF::Font->open($ARGV[0]) || die "Can't open file '$ARGV[0]'";
}

if ($opts{'d'})
{
    # expand magic words.
    $opts{'d'} =~ s/\bgraphite\b/ Silf Feat Gloc Glat Sill Sile /oi; 
    $opts{'d'} =~ s/\bvolt\b/ TSIV TSID TSIP TSIS /oi;
    $opts{'d'} =~ s/\bopentype\b/ GDEF GSUB GPOS /oi;
    # Split generously (spaces, comma, colon, semicolon)
    foreach my $tag (grep {length($_) == 4} split(/[\s,:;]+/, $opts{'d'}))
    {
    	delete $f->{$tag} if exists $f->{$tag};
    }
}

my $cmap = $f->{'cmap'}->read->find_ms;
my $post = $f->{'post'}->read;
my $numg = $f->{'maxp'}{'numGlyphs'};
my $subsetter = Font::TTF::Scripts::SubSetter->new($numg);
if ($opts{'g'})
{
    my ($fh) = IO::File->new($opts{'g'}, "r") || die "Can't open $opts{'g'} for reading";
    while (<$fh>)
    {
        foreach my $g (split)
        {
            my ($n, $u) = split(/=/, $g);
            if ($n =~ m/^U\+/oi)
            { $n = $cmap->{'val'}{hex($')}; }
            elsif ($n !~ m/^\d/o)
            { $n = $post->{'STRINGS'}{$n}; }
            if ($n)
            {
                $subsetter->add_glyph($n);
                if ($u)
                { $subsetter->remap(hex($u), $n); }
            }
        }
    }
    $fh->close();
}

if ($opts{'l'})
{ $subsetter->langlist(split(' ', $opts{'l'})); }

if ($opts{'s'})
{ $subsetter->scriptlist(split(' ', $opts{'s'})); }

my ($canchangegids) = 1;
$f->tables_do(sub {$canchangegids &= $_[0]->canchangegids();});
$numg = $subsetter->creategidmap() if ($canchangegids);

$f->{'loca'}->subset($subsetter);
$f->tables_do(sub {$_[0]->subset($subsetter);});
$f->{'maxp'}{'numGlyphs'} = $subsetter->{'gcount'};
$f->tables_do(sub {$_[0]->update;});
ttfname($f, "q" => 1, "n" => $opts{'n'}) if ($opts{'n'});
$f->out($ARGV[1]);

package Font::TTF::Scripts::SubSetter;

sub new
{
    my ($class, $numg) = @_;
    my ($self) = {};
    $self->{'glyphs'} = '';
    $self->{'remaps'} = {};
    $self->{'numg'} = $numg;
    bless $self, $class || ref $class;
    foreach (0..2) { $self->add_glyph($_); }
    return $self;
}

sub add_glyph
{
    my ($self, $n, $private) = @_;
    if (($private && !$self->{'gidmap'}[$n]) || (!$private && !vec($self->{'glyphs'}, $n, 1)))
    {
        vec($self->{'glyphs'}, $n, 1) = 1; # unless ($private);
        $self->{'gidmap'}[$n] = $self->{'gcount'}++ if (defined $self->{'gidmap'});
        return 1;
    }
    else
    { return 0; }
}

sub keep_glyph
{
    my ($self, $n) = @_;
    return vec($self->{'glyphs'}, $n, 1);
}

sub remap
{
    my ($self, $u, $n) = @_;
    $self->{'remaps'}{$u} = $n;
}

sub langlist
{
    my ($self, @dat) = @_;
    $self->{'langs'} = { map {$_=>1} @dat };
}

sub scriptlist
{
    my ($self, @dat) = @_;
    $self->{'scripts'} = { map {$_=>1} @dat };
}

sub creategidmap
{
    my ($self) = @_;
    my ($numg) = $self->{'numg'};
    my ($count) = 0;

    $self->{'gidmap'} = [];
    $self->{'gcount'} = 0;
    foreach my $i (0 .. $numg - 1)
    { push (@{$self->{'gidmap'}}, vec($self->{'glyphs'}, $i, 1) ? $self->{'gcount'}++ : 0); }
    return $self->{'gcount'};
}

sub map_glyph
{
    my ($self, $g) = @_;
    # no glyph remapping yet
    if ($self->{'gidmap'})
    { return $self->{'gidmap'}[$g]; }
    else
    { return $g; }
}

package Font::TTF::Table;

sub canchangegids
{ 1; }

sub subset
{
    my ($self, $subsetter) = @_;
    return 0 if ($self->{' subsetdone'});
    $self->{' subsetdone'} = 1;
    $self->read;
    $self->dirty;
    return 1;
}

package Font::TTF::Loca;

sub subset
{
    my ($self, $subsetter) = @_;
    my ($res) = [];
    my ($i, $vec);

    return unless ($self->SUPER::subset($subsetter));
    for ($i = 0; $i < @{$self->{'glyphs'}}; $i++)
    {
        if ($subsetter->keep_glyph($i))
        { $self->outglyph($subsetter, $res, $i); }
    }
    $self->{'glyphs'} = $res;
}

sub outglyph
{
    my ($self, $subsetter, $res, $n) = @_;

    $res->[$subsetter->map_glyph($n)] = $self->{'glyphs'}[$n];
    if (defined $self->{'glyphs'}[$n] && $self->{'glyphs'}[$n]->read()->{'numberOfContours'} < 0)
    {
        my ($g) = $self->{'glyphs'}[$n]->read_dat();
        foreach my $c (@{$g->{'comps'}})
        {
            if ($subsetter->add_glyph($c->{'glyph'}, 1))
            { $self->outglyph($subsetter, $res, $c->{'glyph'}); }
            $c->{'glyph'} = $subsetter->map_glyph($c->{'glyph'});
        }
        $g->{' isDirty'} = 1;
    }
}

package Font::TTF::Ttopen;

sub subset
{
    my ($self, $subsetter) = @_;
    return unless ($self->SUPER::subset($subsetter));

    my ($l, $count, @lmap, @lookups, $lkvec, $res, $nlookup);
    $lkvec = "";
    $nlookup = $#{$self->{'LOOKUP'}};
    # process non-contextual lookups
    foreach $l (0 .. $nlookup)
    {
        my ($type) = $self->{'LOOKUP'}[$l]{'TYPE'};
        next if ($type >= $self->extension() - 2 && $type < $self->extension());
        $res = $self->subset_lookup($self->{'LOOKUP'}[$l]);

        if (!@{$res})
        {
            delete $self->{'LOOKUP'}[$l];
            vec($lkvec, $l, 1) = 0;
        }
        else
        {
            $self->{'LOOKUP'}[$l]{'SUB'} = $res;
            vec($lkvec, $l, 1) = 1;
        }
    }
    # now process contextual lookups knowing whether the other lookup is there
    # also collect the complete lookup list now
    foreach $l (0 .. $nlookup)
    {
        if (defined $self->{'LOOKUP'}[$l])
        {
            my ($type) = $self->{'LOOKUP'}[$l]{'TYPE'};
            if ($type >= $self->extension() - 2 && $type < $self->extension())
            {
                $res = $self->subset_lookup($self->{'LOOKUP'}[$l], $lkvec);
                if (!@{$res})
                {
                    delete $self->{'LOOKUP'}[$l];
                    vec($lkvec, $l, 1) = 0;
                }
                else
                {
                    $self->{'LOOKUP'}[$l]{'SUB'} = $res;
                    vec($lkvec, $l, 1) = 1;
                }
            }
        }
        if (vec($lkvec, $l, 1))
        {
            push (@lookups, $self->{'LOOKUP'}[$l]);
            push (@lmap, $count++);
        }
        else
        { push (@lmap, -1); }
    }
    
    $self->{'LOOKUP'} = \@lookups;
    foreach $l (@lookups)
    { $self->fixcontext($l, \@lmap); }

    foreach my $t (@{$self->{'FEATURES'}{'FEAT_TAGS'}})
    {
        my $f = $self->{'FEATURES'}{$t};
        foreach $l (0 .. $#{$f->{'LOOKUPS'}})
        {
            my ($v) = $lmap[$f->{'LOOKUPS'}[$l]];
            if ($v < 0)
            { delete $f->{'LOOKUPS'}[$l]; }
            else
            { $f->{'LOOKUPS'}[$l] = $v; }
        }
        if (!@{$f->{'LOOKUPS'}})
        { delete $self->{'FEATURES'}{$t}; }
        else
        { $f->{'LOOKUPS'} = [grep {defined $_} @{$f->{'LOOKUPS'}}]; }
    }
    $self->{'FEATURES'}{'FEAT_TAGS'} = [grep {defined $self->{'FEATURES'}{$_}} @{$self->{'FEATURES'}{'FEAT_TAGS'}}];

    my ($isEmpty) = 1;
    foreach my $s (keys %{$self->{'SCRIPTS'}})
    {
        foreach $l (-1 .. $#{$self->{'SCRIPTS'}{$s}{'LANG_TAGS'}})
        {
            my $lang;
            if ($l < 0)
            { $lang = $self->{'SCRIPTS'}{$s}{'DEFAULT'}; }
            else
            { $lang = $self->{'SCRIPTS'}{$s}{$self->{'SCRIPTS'}{$s}{'LANG_TAGS'}[$l]}; }

            if (defined $lang->{'FEATURES'})
            {
                foreach my $i (0 .. @{$lang->{'FEATURES'}})
                {
                    if (!defined $self->{'FEATURES'}{$lang->{'FEATURES'}[$i]})
                    { delete $lang->{'FEATURES'}[$i]; }
                }
                $lang->{'FEATURES'} = [grep {$_} @{$lang->{'FEATURES'}}];
            }
            if (defined $lang->{'DEFAULT'} && $lang->{'DEFAULT'} >= 0)
            {
                my ($found) = 0;
                foreach my $f (@{$self->{'FEATURES'}{'FEAT_TAGS'}})
                {
                    if ($self->{'FEATURES'}{$f}{'INDEX'} == $lang->{'DEFAULT'})
                    {
                        $found = 1;
                        last;
                    }
                }
                if (!$found)
                { $lang->{'DEFAULT'} = -1; }
            }
            if (($l >= 0 && defined $subsetter->{'langs'}
                && !defined $subsetter->{'langs'}{$self->{'SCRIPTS'}{$s}{'LANG_TAGS'}[$l]})
                    || ((!defined $lang->{'FEATURES'} || !@{$lang->{'FEATURES'}})
                        && (!defined $lang->{'DEFAULT'} || $lang->{'DEFAULT'} < 0)))
            {
                if ($l < 0)
                { delete $self->{'SCRIPTS'}{$s}{'DEFAULT'}; }
                else
                {
                    delete $self->{'SCRIPTS'}{$s}{$self->{'SCRIPTS'}{$s}{'LANG_TAGS'}[$l]};
                    delete $self->{'SCRIPTS'}{$s}{'LANG_TAGS'}[$l];
                }
            }
        }
        if ((defined $subsetter->{'scripts'} && !defined $subsetter->{'scripts'}{$s})
                || (!@{$self->{'SCRIPTS'}{$s}{'LANG_TAGS'}} && !defined $self->{'SCRIPTS'}{$s}{'DEFAULT'}))
        {
            delete $self->{'SCRIPTS'}{$s};
            next;
        }
        else
        { $isEmpty = 0; }
    }
    if ($isEmpty)
    {
        my ($k, $v);
        while (($k, $v) = each %{$self->{' PARENT'}})
        {
            if ($v eq $self)
            {
                delete $self->{' PARENT'}{$k};
                last;
            }
        }
    }
}

sub subset_lookup
{
    my ($self, $lookup, $lkvec) = @_;
    my ($s, $l);
    my ($res) = [];

    foreach $s (@{$lookup->{'SUB'}})
    {
        if (!$self->subset_subtable($subsetter, $s, $lookup, $lkvec)
            || !defined $s->{'RULES'} || !@{$s->{'RULES'}})
        { next; }
        $s->{'RULES'} = [grep {$_} @{$s->{'RULES'}}];
        # remove unused coverage indices
        if ($s->{'COVERAGE'})
        {
            my $c = $s->{'COVERAGE'}{'val'};
            my $i = 0;
            foreach my $k (sort {$c->{$a} <=> $c->{$b}} keys %{$c})
            { $c->{$k} = $i++; }
        }
        push (@{$res}, $s);
    }
    return $res;
}


sub subset_class
{
    my ($self, $subsetter, $classdef, $noremap) = @_;
    my ($res) = [];
    my ($count) = 0;
    my ($class) = $classdef->{'val'};

    foreach (sort {$a <=> $b} keys %{$class})
    {
        if (!$subsetter->keep_glyph($_))
        { delete $class->{$_}; }
        else
        {
            my $g = $subsetter->map_glyph($_);
            $class->{$g} = delete $class->{$_};
            $res->[$class->{$g}] = ++$count unless (defined $res->[$class->{$g}])
        }
    }
    # remap the class
    unless ($noremap)
    {
        foreach (keys %{$class})
        { $class->{$_} = $res->[$class->{$_}]; }
    }
    if (@{$res})
    { return $res; }
    else
    { return undef; }
}

sub subset_cover
{
    my ($self, $subsetter, $coverage, $rules) = @_;
    return $coverage if (defined $coverage->{'isremapped'});
    my $isEmpty = 1;
    my $cover = $coverage->{'val'};
    foreach (sort {$a <=> $b} keys %{$cover})
    {
        if (!$subsetter->keep_glyph($_))
        {
            delete $rules->[$cover->{$_}] if $rules;
            delete $cover->{$_};
        }
        else
        {
            $cover->{$subsetter->map_glyph($_)} = delete $cover->{$_};
            $isEmpty = 0;
        }
    }
    if ($isEmpty)
    { return undef; }
    else
    {
        $coverage->{'isremapped'} = 1;
        return $coverage;
    }
}

sub subset_string
{
    my ($self, $subsetter, $string, $fmt, $classvals) = @_;
    my ($test) = 1;

    return 0 if ($fmt == 2 && !$classvals);
    foreach (@{$string})
    {
        if ($fmt == 1 && $subsetter->keep_glyph($_))
        { $_ = $subsetter->map_glyph($_); }
        elsif ($fmt == 2 && defined $classvals->[$_])
        { $_ = $classvals->[$_]; }
        elsif ($fmt == 3 && $self->subset_cover($subsetter, $_, undef))
        { }
        else
        {
            $test = 0;
            last;
        }
    }
    return $test;
}

sub subset_context
{
    my ($self, $subsetter, $sub, $type, $lkvec) = @_;
    my ($fmt) = $sub->{'FORMAT'};
    my ($classvals, $prevals, $postvals, $i, $j, @gids);

    return 0 if (defined $sub->{'COVERAGE'} && !$self->subset_cover($subsetter, $sub->{'COVERAGE'}, $fmt < 2 ? $sub->{'RULES'} : undef));
    while (my ($k, $v) = each %{$sub->{'COVERAGE'}{'val'}})
    { $gids[$v] = $k; }
    return 0 if (defined $sub->{'CLASS'} && !($classvals = $self->subset_class($subsetter, $sub->{'CLASS'})));
    return 0 if (defined $sub->{'PRE_CLASS'} && !($prevals = $self->subset_class($subsetter, $sub->{'PRE_CLASS'})));
    return 0 if (defined $sub->{'POST_CLASS'} && !($postvals = $self->subset_class($subsetter, $sub->{'POST_CLASS'})));
    # tidy up coverage tables that contain glyphs not in the matching class
#    if (defined $sub->{'CLASS'})
#    {
#        foreach $i (0 .. $#gids)
#        {
#            if (defined $gids[$i] && !defined $sub->{'CLASS'}{'val'}{$gids[$i]})
#            {
#                delete $sub->{'COVERAGE'}{'val'}{$gids[$i]};
#                delete $gids[$i];
#            }
#        }
#        @gids = grep {defined $_} @gids;
#    }
#    return 0 unless (@gids);


    foreach $i (0 .. @{$sub->{'RULES'}})
    {
        my ($isEmpty) = 1;
        if ($sub->{'RULES'}[$i])
        {
            foreach $j (0 .. $#{$sub->{'RULES'}[$i]})
            {
                my ($r) = $sub->{'RULES'}[$i][$j];
                my ($test) = 1;
                if ($type == 4)
                {
                    if ($subsetter->keep_glyph($r->{'ACTION'}[0]))
                    { $r->{'ACTION'}[0] = $subsetter->map_glyph($r->{'ACTION'}[0]); }
                    else
                    { $test = 0; }
                }
                else
                {
                    foreach my $k (0 .. $#{$sub->{'RULES'}[$i][$j]{'ACTION'}})
                    {
                        my $a = $sub->{'RULES'}[$i][$j]{'ACTION'}[$k];
                        if (!vec($lkvec, $a->[1], 1))
                        { delete $sub->{'RULES'}[$i][$j]{'ACTION'}[$k]; }
                    }
                    $test = (@{$sub->{'RULES'}[$i][$j]{'ACTION'}} != 0);
                }
                if ($test && $type == 6 && defined $r->{'PRE'})
                { $test = $self->subset_string($subsetter, $r->{'PRE'}, $fmt, $prevals); }
                if ($test && $type == 6 && defined $r->{'POST'})
                { $test = $self->subset_string($subsetter, $r->{'POST'}, $fmt, $postvals); }
                if ($test)
                { $test = $self->subset_string($subsetter, $r->{'MATCH'}, $fmt, $classvals); }
                if (!$test)
                { delete $sub->{'RULES'}[$i][$j]; }
                else
                { $isEmpty = 0; }
            }
            $sub->{'RULES'}[$i] = [grep {$_} @{$sub->{'RULES'}[$i]}];
        }
        if ($isEmpty)
        {
            delete $sub->{'RULES'}[$i];
            delete $sub->{'COVERAGE'}{'val'}{$gids[$i]} if ($fmt < 2);  # already remapped
        }
    }
    return 1;
}

sub fixcontext
{
    my ($self, $l, $lmap) = @_;

    return if ($l->{'TYPE'} < $self->extension() - 2 || $l->{'TYPE'} >= $self->extension());
    foreach my $s (@{$l->{'SUB'}})
    {
        foreach my $r (@{$s->{'RULES'}})
        {
            foreach my $p (@{$r})
            {
                foreach my $b (@{$p->{'ACTION'}})
                { $b->[1] = $lmap->[$b->[1]]; }
            }
        }
    }
}


package Font::TTF::GSUB;

sub subset_subtable
{
    my ($self, $subsetter, $sub, $lookup, $lkvec) = @_;
    my ($type) = $lookup->{'TYPE'};
    my ($fmt) = $sub->{'FORMAT'};
    my ($r, $i, $j, @gids, $k, $v);

    return 0 if ($type < 4 && !$self->subset_cover($subsetter, $sub->{'COVERAGE'}, $sub->{'RULES'}));

    while (($k, $v) = each %{$sub->{'COVERAGE'}{'val'}})
    { $gids[$v] = $k; }

    if (($type == 1 && $fmt > 1) || $type == 2)
    {
        foreach $i (0 .. $#{$sub->{'RULES'}})
        {
            next unless (defined $sub->{'RULES'}[$i]);
            foreach my $k (0 .. $#{$sub->{'RULES'}[$i][0]{'ACTION'}})
            {
                $j = $sub->{'RULES'}[$i][0]{'ACTION'}[$k];
                if (!$subsetter->keep_glyph($j))
                {
                    delete $sub->{'RULES'}[$i];
                    delete $sub->{'COVERAGE'}{'val'}{$gids[$i]}; # already remapped
                    last;
                }
                else
                { $sub->{'RULES'}[$i][0]{'ACTION'}[$k] = $subsetter->map_glyph($j); }
            }
        }
    }
    elsif ($type == 3)
    {
        foreach $i (0 .. $#{$sub->{'RULES'}})
        {
            if (!defined $sub->{'RULES'}[$i])
            {
                delete $sub->{'COVERAGE'}{'val'}{$gids[$i]};
                next;
            }
            my $res = [];
            foreach $j (@{$sub->{'RULES'}[$i][0]{'ACTION'}})
            {
                if ($subsetter->keep_glyph($j))
                { push (@{$res}, $subsetter->map_glyph($j)); }
            }
            if (@{$res})
            { $sub->{'RULES'}[$i][0]{'ACTION'} = $res; }
            else
            {
                delete $sub->{'RULES'}[$i];
                delete $sub->{'COVERAGE'}{'val'}{$gids[$i]};  # already remapped
            }
        }
    }
    elsif ($type >=4 && $type <= 6)
    { return $self->subset_context($subsetter, $sub, $type, $lkvec); }
    return 1;
}

package Font::TTF::GPOS;

sub subset_subtable
{
    my ($self, $subsetter, $sub, $lookup, $lkvec) = @_;
    my ($type) = $lookup->{'TYPE'};
    my ($fmt) = $sub->{'FORMAT'};
    my (@gids) = sort { $a <=> $b} keys %{$sub->{'COVERAGE'}{'val'}};
    my ($i, $j, $k);

    return 0 if ($type <= 6 && !$self->subset_cover($subsetter, $sub->{'COVERAGE'}, $sub->{'RULES'}));
    if ($type == 2 && $fmt == 1)
    {
        foreach $i (0 .. $#{$sub->{'RULES'}})
        {
            foreach $j (0 .. $#{$sub->{'RULES'}[$i]})
            {
                my ($r) = $sub->{'RULES'}[$i][$j];
                if (!$subsetter->keep_glyph($r->{'MATCH'}[0]))
                { delete $sub->{'RULES'}[$i][$j]; }
                else
                { $r->{'MATCH'}[0] = $subsetter->map_glyph($r->{'MATCH'}[0]); }
            }
            if (!@{$sub->{'RULES'}[$i]})
            { delete $sub->{'RULES'}[$i]; }
            else
            { $sub->{'RULES'}[$i] = [grep {$_} @{$sub->{'RULES'}[$i]}]; }
        }
    }
    elsif ($type == 2 && $fmt == 2)
    {
        my ($c1vals) = $self->subset_class($subsetter, $sub->{'CLASS'});
        my ($c2vals) = $self->subset_class($subsetter, $sub->{'MATCH'}[0]);
        my ($nrules) = [];
        
        foreach $i (0 .. $#{$sub->{'RULES'}})
        {
            if (!$c1vals->[$i])
            { delete $sub->{'RULES'}[$i]; }
            else
            {
                my (@nrule);
                foreach $j (0 .. $#{$sub->{'RULES'}[$i]})
                {
                    if (!defined $c2vals->[$j])
                    { delete $sub->{'RULES'}[$i][$j]; }
                    else
                    { $nrule[$c2vals->[$j]] = $sub->{'RULES'}[$i][$j]; }
                }
                if (@nrule)
                { $nrules->[$c1vals->[$i]] = [grep {$_} @nrule]; }
            }
        }
        if (@{$nrules})
        { $sub->{'RULES'} = $nrules; }
        else
        { return 0; }
    }
    elsif ($type >= 4 && $type <= 6)
    { return $self->subset_cover($subsetter, $sub->{'MATCH'}[0], $sub->{'MARKS'}) ? 1 : 0; }
    elsif ($type >=7 && $type <= 8)
    { return $self->subset_context($subsetter, $sub, $type - 2, $lkvec); }
    return 1;
}

package Font::TTF::GDEF;

sub subset
{
    my ($self, $subsetter) = @_;

    return unless ($self->SUPER::subset($subsetter));
    if (defined $self->{'GLYPH'})
    { delete $self->{'GLYPH'} unless (Font::TTF::Ttopen->subset_class($subsetter, $self->{'GLYPH'}, 1)); }
    if (defined $self->{'ATTACH'})
    { delete $self->{'ATTACH'} unless (Font::TTF::Ttopen->subset_cover($subsetter, $self->{'ATTACH'}{'COVERAGE'}, $self->{'ATTACH'}{'POINTS'})); }
    if (defined $self->{'LIG'})
    { delete $self->{'LIG'} unless (Font::TTF::Ttopen->subset_cover($subsetter, $self->{'LIG'}{'COVERAGE'}, $self->{'LIG'}{'POINTS'})); }
    if (defined $self->{'MARKS'})
    { delete $self->{'MARKS'} unless (Font::TTF::Ttopen->subset_cover($subsetter, $self->{'MARKS'}, undef)); }
}

package Font::TTF::Cmap;

sub subset
{
    my ($self, $subsetter) = @_;

    return unless ($self->SUPER::subset($subsetter));
    foreach my $i (0 .. $#{$self->{'Tables'}})
    {
        my ($t) = $self->{'Tables'}[$i]{'val'};
        foreach my $k (keys %{$t})
        {
            if ($subsetter->keep_glyph($t->{$k}))
            { $t->{$k} = $subsetter->map_glyph($t->{$k}); }
            else
            { delete $t->{$k}; }
        }
        if ($self->is_unicode($i))
        {
            foreach my $k (keys %{$subsetter->{'remaps'}})
            { $t->{$k} = $subsetter->map_glyph($subsetter->{'remaps'}{$k}); }
        }
    }
}

package Font::TTF::Post;

sub subset
{
    my ($self, $subsetter) = @_;
    my ($res) = [];

    return unless ($self->SUPER::subset($subsetter));
    # need to rewrite for real glyph remapping
    foreach my $i (0 .. @{$self->{'VAL'}})
    { $res->[$subsetter->map_glyph($i)] = $subsetter->keep_glyph($i) ? $self->{'VAL'}[$i] : ".notdef"; }
    $self->{'VAL'} = $res;
}

package Font::TTF::Hmtx;

sub subset
{
    my ($self, $subsetter) = @_;
    my ($adv) = [];
    my ($lsb) = [];

    return unless ($self->SUPER::subset($subsetter));
    for (my $i = 0; $i < @{$self->{'advance'}}; $i++)
    {
        if ($subsetter->keep_glyph($i))
        {
            my ($g) = $subsetter->map_glyph($i);
            $adv->[$g] = $self->{'advance'}[$i];
            $lsb->[$g] = $self->{'lsb'}[$i];
        }
    }
    $self->{'advance'} = $adv;
    $self->{'lsb'} = $lsb;
}

package Font::TTF::LTSH;

sub subset
{
    my ($self, $subsetter) = @_;
    my ($res) = [];

    return unless ($self->SUPER::subset($subsetter));
    for (my $i = 0; $i < @{$self->{'glyphs'}}; $i++)
    {
        if ($subsetter->keep_glyph($i))
        { $res->[$subsetter->map_glyph($i)] = $self->{'glyphs'}[$i]; }
    }
    $self->{'glyphs'} = $res;
    $self->{'Num'} = $subsetter->{'gcount'};
}


package Font::TTF::Gloc;

sub canchangegids
{ 0; }


package Font::TTF::Silf;

# disable for now so we can check in initial code
sub _subset
{
    my ($self, $subsetter) = @_;
    my ($s);

    foreach $s (@{$self->{'SILF'}})
    { $self->subset_silf($s, $subsetter); }
}

sub subset_silf
{
    my ($self, $silf, $subsetter) = @_;
    my ($p, $count);

    foreach $p (@{$silf->{'PASS'}})
    {
        my ($cinfo) = {};
        push (@{$subsetter->{'silf'}{'passes'}}, $cinfo);
        $self->markdels($p, $subsetter, $cinfo);
    }

    # calculate substitution classes 
    for (my $i = 0; $i < scalar @{$self->{'classes'}}; $i++)
    {
        my (@subsetclass) = grep ($subsetter->keep_glyph($_), @{$self->{'classes'}[$i]});
        unless (scalar @subsetclass)
        {
            $subsetter->{'silf'}{'numclass'}[$i] = -1;
            next unless (defined $subsetter->{'silf'}{'numclass_pairs'}{$i});
            while (my ($k, $v) = each %{$subsetter->{'silf'}{'numclass_pairs'}{$i}})
            { $v = -1; }
            next;
        }
        next unless (defined $subsetter->{'silf'}{'numclass_pairs'}{$i});
        while (my ($k, $v) = each %{$subsetter->{'silf'}{'numclass_pairs'}{$i}})
        {
            next if ($v < 0);
            my (@subother) = grep ($subsetter->keep_glyphs($_), @{$self->{'classes'}[$k]});
            next if (scalar @subother == scalar @{$self->{'classes'}[$k]} and
                scalar @subsetclass == scalar @{$self->{'classes'}[$i]});
            @subother = ();
            my (@subthis) = ();
            for (my $j = 0; $j < @{$self->{'classes'}[$i]}; $j++)
            {
                my ($a) = $self->{'classes'}[$i][$j];
                my ($b) = $self->{'classes'}[$k][$j];
                if ($subsetter->keep_glyph($a) and $subsetter->keep_glyph($b))
                {
                    push (@subother, $b);
                    push (@subthis, $a);
                }
            }
            if (!scalar @subthis)
            { $subsetter->{'silf'}{'numclass_pairs'}{$i}{$k} = -1; }
            else
            { $subsetter->{'silf'}{'class_pairs'}{$i}{$k} = [[@subthis], [@subother]]; }
        }
    }

    # see what other rules we can delete
    for (my $i = 0; $i < scalar @{$self->{'PASS'}}; $i++)
    { $self->testrules($self->{'PASS'}[$i], $subsetter, $subsetter->{'silf'}{'passes'}[$i]); }

    # make new, mapped, classes and a map from one to the other, update class_pairs to return [in_new_class_id, out_new_class_id]
    # also do class reduction.
    $subsetter->{'silf'}{'classes'} = [];
    $subsetter->{'silf'}{'classmap'} = [];
    for (my $i = 0; $i < scalar @{$self->{'classes'}}; $i++)
    {
        my (@newclass) = map ($subsetter->map_glyph($_), @{$self->{'classes'}[$i]});
        if (scalar @newclass)
        {
            push (@{$subsetter->{'silf'}{'classes'}}, [@newclass]);
            push (@{$subsetter->{'silf'}{'classmap'}}, $#{$subsetter->{'silf'}{'classes'}});
        }
        else
        { push (@{$subsetter->{'silf'}{'classmap'}}, -1); }
        next unless (defined $subsetter->{'class_pairs'}{$i});
        while(my ($k,$v) = each %{$subsetter->{'class_pairs'}{$i}})
        { $v = [map($self->addmappedclass($_, $subsetter), @{$v})]; }
    }

    # see what other rules we can delete
    for (my $i = 0; $i < scalar @{$self->{'PASS'}}; $i++)
    { $self->finalise_pass($self->{'PASS'}[$i], $subsetter, $subsetter->{'silf'}{'passes'}[$i]); }
}

# algorithm section 1
sub markdels
{
    my ($self, $pass, $subsetter, $cinfo) = @_;

    # 1.2 mark kept columns
    for (my $i = 0; $i < $subsetter->{'numg'}; ++$i)
    {
        if (defined $pass->{'colmap'}{$i} and $subsetter->keep_glyph($i))
        { vec($cinfo->{'cols'}, $i, 1) = 1; }
    }

    # prepare back references to allow easy row deletion
    # empty rowfwdrefs means deleted.
    $cinfo->{'rowfwdrefs'} = [];
    $cinfo->{'rowbackrefs'} = [];
    for (my $i = 0; $i < scalar @{$pass->{'fsm'}}; $i++)
    {
        my ($fsm) = $pass->{'fsm'}[$i];
        $cinfo->{'rowfwdrefs'}[$i] = [];
        $cinfo->{'rowbackrefs'}[$i] = [];
        for (my $j = 0; $j < scalar @{$fsm}; $j++)
        {
            my ($t) = $fsm->[$j];
            next unless ($t or !vec($cinfo->{'cols'}, $j, 1));
            push(@{$cinfo->{'rowfwdrefs'}[$i]}, $t);
            push(@{$cinfo->{'rowbackrefs'}[$t]}, $i);;
        }
    }
    # delete all rows that are not referenced
    for (my $i = 0; $i < scalar @{$pass->{'fsm'}}; $i++)
    {
        next unless (grep($_ == $i, @{$pass->{'startStates'}}));
        my (@brefs) = keys %{$cinfo->{'rowbackrefs'}[$i]};
        $self->delrow($pass, $cinfo, $i) unless (scalar @brefs);
    }

    # 1.4 mark kept rules
    # row value can be 0, 1, 3; never is 2, since how can you have outgoing if you aren't reached.
    for (my $i = $pass->{'numRows'} - $pass->{'numSuccess'}; $i < $pass->{'numRows'}; ++$i)
    {
        if (@{$cinfo->{'rowrefcounts'}[$i]})
        {
            foreach (@{$pass->{'rulemap'}[$i - $pass->{'numRows'} + $pass->{'numSuccess'}]})
            { push (@{$cinfo->{'rules'}[$_]}, $i); }
        }
    }

    # 1.5 analyse test constraint code and possibly delete.

    # 1.6 parse and associate substitutionary classes
    for (my $i = 0; $i < $pass->{'numRules'}; ++$i)
    {
        next unless (@{$cinfo->{'rules'}[$i]});
        my (@rinfo) = $self->unpack_code($pass->{'actionCode'}[$i]);
        foreach my $r (@rinfo)
        {
            if ($r->[0] eq 'put_subs_8bit_obs' or $r->[0] eq 'put_subs')
            { $subsetter->{'silf'}{'numclass_pairs'}{$r->[2]}{$r->[3]}++; }
            elsif ($r->[0] eq 'put_glyph_8bit_obs' or $r->[0] eq 'put_glyph')
            { $subsetter->{'silf'}{'numclasses'}{$r->[1]}++; }
        }
    }
}

sub testrules
{
    my ($self, $pass, $subsetter, $cinfo) = @_;

    for (my $i = 0; $i < $pass->{'numRules'}; ++$i)
    {
        next unless (@{$cinfo->{'rules'}[$i]});
        my (@rinfo) = $self->unpack_code($pass->{'actionCode'}[$i]);
        foreach my $r (@rinfo)
        {
            if ((   ($r->[0] eq 'put_subs_8bit_obs' or $r->[0] eq 'put_subs')
                     and $subsetter->{'silf'}{'numclass_pairs'}{$r->[2]}{$r->[3]} < 0)
                or  ($r->[0] eq 'put_glyph_8bit_obs' or $r->[0] eq 'put_glyph')
                     and $subsetter->{'silf'}{'numclasses'}{$r->[1]} < 0)
            { $self->delrule($pass, $subsetter, $cinfo, $i); }
        }
    }
}

sub finalise_pass
{
    my ($self, $pass, $subsetter, $cinfo) = @_;

    # 5.3 create rowmap
    my (@rowmap);
    my ($numrows);
    for (my $i = 0; $i < $pass->{'numRows'}; $i++)
    {
        if (@{$cinfo->{'rowbackrefs'}[$i]} and @{$cinfo->{'rowfwdrefs'}[$i]})
        { push (@rowmap, $numrows++); }
        else
        { push (@rowmap, -1); }
    }

    # create column map
    my (@colmap);
    my ($numcolumns);
    for (my $j = 0; $j < $pass->{'numColumns'}; $j++)
    {
        if (vec($cinfo->{'cols'}, $j, 1))
        { push (@colmap, $numcolumns++); }
        else
        { push (@colmap, -1); }
    }

    # 5.4 create rule map
    my (@rulemap);
    my ($numrules);
    for (my $i = 0; $i < $pass->{'numRules'}; $i++)
    {
        if (@{$cinfo->{'rules'}[$i]})
        { push (@rulemap, $numrules++); }
        else
        { push (@rulemap, -1); }
    }

    # 5.5 create fsm
    my (@fsm);
    for (my $i = 0; $i < $pass->{'numRows'}; $i++)
    {
        if ($rowmap[$i] >= 0)
        {
            my (@row);
            for (my $j = 0; $j < $pass->{'numColumns'}; $j++)
            {
                if (vec($cinfo->{'cols'}, $j, 1))
                {
                    my ($f) = $pass->{'fsm'}[$i][$j];
                    if ($rowmap[$f] < 0)
                    { warn "Bad fsm mapping at $i, $j"; }
                    else
                    { push (@row, $f == 0 ? 0 : $rowmap[$f]); }
                }
            }
            push (@fsm, [@row]);
        }
    }

    # 5.6, 5.7 create row->rule lists and remap rules and the like
    my (@rules);
    my (@rowrules, @keys, @prectxts);
    for (my $i = 0; $i < $pass->{'numRules'}; $i++)
    {
        next if ($rulemap[$i] < 0);
        my (@rinfo) = $self->unpack_code($pass->{'actionCode'}[$i]);
        foreach my $r (@rinfo)
        {
            if ($r->[0] eq 'put_subs_8bit_obs' or $r->[0] eq 'put_subs')
            {
                if (defined $subsetter->{'silf'}{'class_pairs'}{$r->[2]}{$r->[3]})
                { ($r->[2], $r->[3]) = @{$subsetter->{'silf'}{'class_pairs'}{$r->[2]}{$r->[3]}}; }
                else
                {
                    $r->[2] = $subsetter->{'silf'}{'classmap'}[$r->[2]];
                    $r->[3] = $subsetter->{'silf'}{'classmap'}[$r->[3]];
                }
            }
            elsif ($r->[0] eq 'put_glyph_8bit_obs' or $r->[0] eq 'put_glyph')
            { $r->[1] = $subsetter->{'silf'}{'classmap'}[$r->[1]]; }
        }
        push (@rules, $self->pack_code(\@rinfo));
        foreach my $r (@{$cinfo->{'rules'}[$i]})
        {
            if ($rulemap[$r] >= 0)
            { push (@{$rowrules[$rulemap[$r]]}, $rulemap[$i]); }
        }
        $keys[$rulemap[$i]] = $pass->{'ruleSortKeys'}[$i];
        $prectxts[$rulemap[$i]] = $pass->{'rulePreContexts'}[$i];
    }
   
    # 5.8 create gid->column mapping
    my (%cols);
    while (my ($k, $v) = each %{$pass->{'colmap'}})
    {
        if ($colmap[$v] >= 0)
        { $cols{$subsetter->map_glyph($k)} = $colmap[$v]; }
    }

    # put everything back
    $pass->{'fsm'} = [@fsm];
    $pass->{'numSuccess'} = $numrows - scanarray($pass->{'numRows'} - $pass->{'numSuccess'}, \@rowmap, 1);
    $pass->{'numTransitional'} = scanarray($pass->{'numTransitional'}, \@rowmap);
    $pass->{'numRows'} = $numrows;
    $pass->{'numColumns'} = $numcolumns;
    $pass->{'colmap'} = {%cols};
    $pass->{'rulemap'} = [@rowrules];
    $pass->{'startStates'} = [map ($rowmap[$_], @{$pass->{'startStates'}})];
    $pass->{'ruleSortKeys'} = [@keys];
    $pass->{'rulePreContexts'} = [@prectxts];
    $pass->{'actionCode'} = [@rules];
    # what about constraint code and pass constraint code?
}

sub scanarray
{
    my ($ind, $arr, $dir) = @_;
    $dir = -1 unless (defined $dir);
    while ($arr->[$ind] < 0)
    { $ind += $dir; }
    return $arr->[$ind];
}

sub delrule
{
    my ($self, $pass, $subsetter, $cinfo, $num) = @_;
    my (@rinfo) = $self->unpack_code($pass->{'actionCode'}[$num]);

#    foreach my $r (@rinfo)
#    {
#        if ($r->[0] eq 'put_subs_8bit_obs' or $r->[0] eq 'put_subs')
#        { $subsetter->{'silf'}{'numclass_pairs'}{$r->[2]}{$r->[3]}--; }
#        elsif ($r->[0] eq 'put_glyph_8bit_obs' or $r->[0] eq 'put_glyph')
#        { $subsetter->{'silf'}{'numclasses'}{$r->[1]}--; }
#    }
    foreach my $r (@{$cinfo->{'rules'}{$num}})
    {
        my ($rentry) = $r - $pass->{'numRows'} + $pass->{'numSuccess'};
        $cinfo->{'rulemap'}[$rentry] = [grep ($_ != $r, @{$cinfo->{'rulemap'}[$rentry]})];
        if (!scalar @{$cinfo->{'rulemap'}[$rentry]} and $r < $pass->{'numTransitional'})
        { $self->delrow($pass, $cinfo, $r); }
    }
    $cinfo->{'rules'}[$num] = [];
}

sub delrow
{
    my ($self, $pass, $cinfo, $row) = @_;

    foreach my $i (@{$pass->{'startStates'}})
    { return if ($i == $row); }

    foreach my $r (@{$cinfo->{'rowfwdrefs'}[$row]})
    {
        $cinfo->{'rowbackrefs'}[$r] = [grep ($_ != $row, @{$cinfo->{'rowbackrefs'}[$r]})];
        $self->delrow($pass, $cinfo, $r) unless (scalar @{$cinfo->{'rowbackrefs'}[$r]});
    }
    $cinfo->{'rowfwdrefs'}[$row] = [];
    foreach my $k (@{$cinfo->{'rowbackrefs'}[$row]})
    {
        $cinfo->{'rowfwdrefs'}[$k] = [grep ($_ != $row, @{$cinfo->{'rowfwdrefs'}[$k]})];
        $self->delrow($pass, $cinfo, $k) unless (scalar @{$cinfo->{'rowfwdrefs'}[$k]});
    }
    $cinfo->{'rowbackrefs'}[$row] = [];
    my (@collist);
    for (my $j = 0; $j < $pass->{'numColumns'}; $j++)
    {
        if (vec($cinfo->{'cols'}, $j, 1) and $pass->{'fsm'}[$row][$j])
        { push (@collist, $j); }
    }
    for (my $i = 0; $i < $pass->{'numTransitional'}; $i++)
    {
        next unless (@{$cinfo->{'rowfwdrefs'}});
        foreach my $j (@collist)
        {
            if ($pass->{'fsm'}[$i][$j])
            { @collist = grep ($_ != $j, @collist); }
        }
    }
    foreach my $j (@collist)
    { vec($cinfo->{'cols'}, $j, 1) = 0; }    
}

sub addmappedclass
{
    my ($self, $class, $subsetter) = @_;
    my ($l) = scalar @{$class};
    my (@m) = map ($subsetter->map_glyph($_), @{$class});

    for (my $i = 0; $i < @{$subsetter->{'classes'}}; $i++)
    {
        my ($c) = $subsetter->{'classes'}[$i];
        next unless (scalar @{$c} == $l);
        if (!grep ($c->[$_] != $m[$_], (0 .. $#{$c})))
        { return $i; }
    }
    push (@{$subsetter->{'classes'}}, [@m]);
    return $#{$subsetter->{'classes'}};
}

__END__

=head1 TITLE

ttfsubset - subset a font

=head1 SYNOPSIS

ttfsubset [options] infont outfont

Opens infont (a .ttf file), subsets it according to the supplied options, then writes the resulting file to outfont.

=head1 OPTIONS

  -h            Get full help
  -d tag[,...]	List of font tables to remove.
  -g listfile	File containing list of glyphs to retain 
  -s tag[,...]	List of OpenType script tags to retain
  -l tag[,...]  List of OpenType language tags to retain
  -n name       Renames the font to the given name (as per ttfname -n)

=head1 DESCRIPTION

ttfsubset removes parts of a font in order to produce a working, smaller, font. Multiple subsetting 
strategies are provided and controlled by options.

The C<-d> option is used to delete whole font tables, e.g., all Graphite tables. A 
list of four-letter table tags identifies the tables to be removed. As in L<ttftable>, 
the following (case insensitive) pseudo tags can also be used:

  graphite  all SIL Graphite tables (Silf Feat Gloc Glat Sill Sile)
  volt      all Microsoft VOLT tables (TSIV TSID TSIP TSIS)
  opentype  all OpenTYpe tables (GDEF GSUB GPOS)

The C<-g> option specifies a file that lists glyphs to be retained in the 
subset font -- ttfsubset will remove all other glyphs and then do what it can to simplify
remaining features.  Glyphs are identified in the file using space-separated indentifiers which
can be decimal numeric glyph IDs, postscript glyph names, or hexidecimal Unicode scalar values in the format
of U+xxxx. Numeric or postscript glyph identifiers can be followed immediately by equals sign and 4 to 6 hex digits to
indicate the glyph should be encoded.

The C<-s> and C<-l> options identify OpenType script and language (respectively) tags
to retain in the font. The Default language is always retained, so specify C<-l ''> to remove all but the default language. 

=head1 BUGS

ttfsubset is an evolving tool and the invitation is given to contribute improvements that will result
in smaller output fonts.

=cut

